#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR=$(cd "$(dirname "$0")/.." && pwd)
HASHFILE="$ROOT_DIR/pkgs/hashfile.json"
HOSTNAME=$(hostname -s)
PLACEHOLDER="sha256-0000000000000000000000000000000000000000000="

require_cmd() {
    command -v "$1" >/dev/null 2>&1 || { echo "Missing: $1" >&2; exit 1; }
}
require_cmd jq
require_cmd curl
require_cmd nix
require_cmd rg

urlencode_npm() {
    printf '%s' "$1" | sed -e 's/@/%40/g' -e 's/\//%2F/g'
}

latest_npm_version() {
    local name="$1"
    local enc
    enc=$(urlencode_npm "$name")
    curl -sL "https://registry.npmjs.org/${enc}" | jq -r '."dist-tags".latest'
}

prefetch_npm_hash() {
    local -a pkgs=("$@")
    local system
    system=$(nix eval --raw --impure --expr 'builtins.currentSystem')

    local tmpfile
    tmpfile=$(mktemp /tmp/prefetch-npm.XXXXXX.nix)

    {
        echo "let"
        echo "  pkgs = import <nixpkgs> { };"
        echo "  npmLib = import ${ROOT_DIR}/libs/npm { inherit pkgs system; };"
        echo "in npmLib.mkNpmGlobalPackageDerivation {"
        echo "  inherit pkgs;"
        echo "  name = \"prefetch\";"
        printf "  packages = ["
        for p in "${pkgs[@]}"; do printf " \"%s\"" "$p"; done
        echo " ];"
        echo "  exposedBinaries = [ ];"
        echo "  outputHash = \"${PLACEHOLDER}\";"
        echo "}"
    } > "$tmpfile"

    set +e
    local out
    out=$(nix build --impure --expr "(import $tmpfile)" -L 2>&1)
    set -e
    rm -f "$tmpfile"

    printf '%s\n' "$out" | sed -n 's/.*got: *\(sha256-[A-Za-z0-9+/=]\+\).*/\1/p' | tail -n1
}

discover_npm_packages() {
    while IFS= read -r f; do
        dirname "$f" | xargs basename
    done < <(rg -l "pkgs\\.lib\\.npm\\.mkNpmGlobalPackageDerivation" "$ROOT_DIR/pkgs" 2>/dev/null || true)
}

get_hashfile_key() {
    local pkg_dir="$1"
    local nix_file="$ROOT_DIR/pkgs/$pkg_dir/default.nix"
    sed -n 's/.*pkgs\.hashfile\."\([^"]*\)".*/\1/p' "$nix_file" | head -n1
}

get_package_spec() {
    local pkg_dir="$1"
    local nix_file="$ROOT_DIR/pkgs/$pkg_dir/default.nix"
    awk '/packages\s*=\s*\[/{flag=1;next}/\]/{flag=0}flag' "$nix_file" | \
        sed -n 's/.*"\(.*\)".*/\1/p' | head -n1
}

update_hashfile() {
    local key="$1"
    local hash="$2"
    local tmp
    tmp=$(mktemp)
    jq --arg h "$HOSTNAME" --arg k "$key" --arg v "$hash" \
        '.[$h][$k] = $v' "$HASHFILE" > "$tmp" && mv "$tmp" "$HASHFILE"
}

sed_inplace() {
    local script="$1" file="$2"
    if sed --version >/dev/null 2>&1; then
        sed -i -e "$script" "$file"
    else
        sed -i '' -e "$script" "$file"
    fi
}

update_package() {
    local pkg_dir="$1"
    local nix_file="$ROOT_DIR/pkgs/$pkg_dir/default.nix"

    echo "==> $pkg_dir"

    local full_spec
    full_spec=$(get_package_spec "$pkg_dir")
    if [[ -z "$full_spec" ]]; then
        echo "  SKIP: no package spec found"
        return 0
    fi

    local npm_name="${full_spec%@*}"
    local current_ver="${full_spec##*@}"

    local latest_ver
    latest_ver=$(latest_npm_version "$npm_name" 2>/dev/null || true)
    if [[ -z "$latest_ver" || "$latest_ver" == "null" ]]; then
        echo "  SKIP: cannot fetch latest version"
        return 1
    fi

    if [[ "$current_ver" == "$latest_ver" ]]; then
        echo "  OK: $current_ver (up to date)"
        return 0
    fi

    echo "  UPDATE: $current_ver -> $latest_ver"

    sed_inplace "s|\"${npm_name}@[^\"]*\"|\"${npm_name}@${latest_ver}\"|" "$nix_file"

    echo "  Prefetching hash..."
    local new_hash
    new_hash=$(prefetch_npm_hash "${npm_name}@${latest_ver}")
    if [[ -z "$new_hash" ]]; then
        echo "  ERROR: failed to get hash"
        return 1
    fi

    local hash_key
    hash_key=$(get_hashfile_key "$pkg_dir")
    update_hashfile "$hash_key" "$new_hash"

    echo "  DONE: $new_hash"
}

main() {
    local -a targets=()

    if [[ $# -gt 0 ]]; then
        targets=("$@")
    else
        while IFS= read -r p; do
            [[ -n "$p" ]] && targets+=("$p")
        done < <(discover_npm_packages)
    fi

    if [[ ${#targets[@]} -eq 0 ]]; then
        echo "No npm packages found"
        exit 0
    fi

    for pkg in "${targets[@]}"; do
        if [[ ! -d "$ROOT_DIR/pkgs/$pkg" ]]; then
            echo "Package not found: $pkg" >&2
            continue
        fi
        update_package "$pkg" || true
    done
}

main "$@"
