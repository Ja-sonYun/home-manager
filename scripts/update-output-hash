#!/usr/bin/env bash
set -euo pipefail

if [[ $# -ne 1 ]]; then
  echo "Usage: $0 <path-to-nix-file>" >&2
  exit 1
fi

ROOT_DIR=$(cd "$(dirname "$0")/.." && pwd)
TARGET_INPUT=$1

if [[ "$TARGET_INPUT" = /* ]]; then
  TARGET_PATH="$TARGET_INPUT"
else
  TARGET_PATH="$ROOT_DIR/$TARGET_INPUT"
fi

if [[ ! -f "$TARGET_PATH" ]]; then
  echo "Target file not found: $TARGET_PATH" >&2
  exit 1
fi

PKGS_DIR="$ROOT_DIR/pkgs"
HASH_FILE="$PKGS_DIR/hash.nix"
PLACEHOLDER_HASH="sha256-0000000000000000000000000000000000000000000="

if [[ ! -f "$HASH_FILE" ]]; then
  echo "Hash map not found: $HASH_FILE" >&2
  exit 1
fi

case "$TARGET_PATH" in
  "$PKGS_DIR"/*)
    RELATIVE_PATH="${TARGET_PATH#${PKGS_DIR}/}"
    ;;
  *)
    echo "Target file must be inside $PKGS_DIR" >&2
    exit 1
    ;;
esac

hash_map_helper() {
  local action="$1"
  shift
  python3 - "$HASH_FILE" "$action" "$@" <<'PY'
import sys
from pathlib import Path

path = Path(sys.argv[1])
action = sys.argv[2]
args = sys.argv[3:]

pattern = None

def load_entries():
    entries = {}
    if path.exists():
        for line in path.read_text().splitlines():
            line = line.strip()
            if not line or line in ('{', '}'):
                continue
            if line.startswith('#'):
                continue
            if line.endswith(';'):
                line = line[:-1].strip()
            if line:
                if '=' not in line:
                    continue
                key_part, value_part = line.split('=', 1)
                key = key_part.strip().strip('"')
                value = value_part.strip().strip('"')
                entries[key] = value
    return entries

def write_entries(entries):
    lines = ['{']
    for key in sorted(entries):
        lines.append(f'  "{key}" = "{entries[key]}";')
    lines.append('}')
    path.write_text('\n'.join(lines) + '\n')

entries = load_entries()

if action == 'get':
    key = args[0]
    if key in entries:
        sys.stdout.write(entries[key])
        sys.exit(0)
    sys.exit(2)

if action == 'set':
    key, value = args
    entries[key] = value
    write_entries(entries)
    sys.exit(0)

if action == 'remove':
    key = args[0]
    if key in entries:
        del entries[key]
    write_entries(entries)
    sys.exit(0)

sys.stderr.write(f'Unknown action: {action}\n')
sys.exit(1)
PY
}

set +e
ORIGINAL_HASH=$(hash_map_helper get "$RELATIVE_PATH")
GET_STATUS=$?
set -e

if [[ $GET_STATUS -eq 0 ]]; then
  ENTRY_PRESENT=true
elif [[ $GET_STATUS -eq 2 ]]; then
  ENTRY_PRESENT=false
  ORIGINAL_HASH=""
else
  echo "Failed to read existing hash entry" >&2
  exit 1
fi

hash_map_helper set "$RELATIVE_PATH" "$PLACEHOLDER_HASH"

RESTORE_NEEDED=true

restore_hash() {
  if [[ ${RESTORE_NEEDED:-false} != true ]]; then
    return
  fi
  if [[ $ENTRY_PRESENT == true ]]; then
    hash_map_helper set "$RELATIVE_PATH" "$ORIGINAL_HASH"
  else
    hash_map_helper remove "$RELATIVE_PATH"
  fi
}

trap restore_hash EXIT

BUILD_EXPR=$(cat <<EXPR
let
  flake = builtins.getFlake (toString ${ROOT_DIR});
  pkgs = import flake.inputs.nixpkgs {
    system = builtins.currentSystem;
    overlays = flake.overlays;
    config.allowUnfree = true;
  };
in pkgs.callPackage ${TARGET_PATH} {}
EXPR
)

set +e
LOG_FILE=$(mktemp)
if ! nix build --extra-experimental-features 'nix-command flakes' --impure --expr "$BUILD_EXPR" -L 2>&1 | tee "$LOG_FILE"; then
  BUILD_STATUS=${PIPESTATUS[0]}
else
  BUILD_STATUS=0
fi
BUILD_LOG=$(cat "$LOG_FILE")
rm -f "$LOG_FILE"
set -e

if [[ $BUILD_STATUS -eq 0 ]]; then
  echo "Unexpected success: placeholder hash did not trigger mismatch." >&2
  printf '%s\n' "$BUILD_LOG"
  exit 1
fi

NEW_HASH=$(printf '%s\n' "$BUILD_LOG" | sed -nE 's/.*got:[[:space:]]*(sha256-[A-Za-z0-9+/=]+).*/\1/p' | tail -n 1)

if [[ -z "$NEW_HASH" ]]; then
  echo "Failed to parse output hash from build." >&2
  printf '%s\n' "$BUILD_LOG"
  exit 1
fi

hash_map_helper set "$RELATIVE_PATH" "$NEW_HASH"
RESTORE_NEEDED=false

trap - EXIT

cat <<MSG
Updated outputHash for $RELATIVE_PATH
  -> $NEW_HASH
MSG
